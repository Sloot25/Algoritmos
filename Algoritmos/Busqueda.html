<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Web Diego</title>
  <link rel="stylesheet" href="../css/Ordenamientos.css" >
  <link res="stylesheet" href="../css/Color.css" >


</head>

<body>

  <div class="header" id="header">
    <div class="container">
      <a href="#" class="logo"> Diego Vidal </a>
      <ul class="main-nav">
	<li><a href="../index.html#algoritmos"> Algoritmos 1 </a></li>
	<li><a href="../index.html#libros"> Libros </a></li>
	<li><a href="../index.html#paginas"> Paginas </a></li>
	<li><a href="../index.html#otros"> Otros </a></li>
      </ul>
    </div>
  </div>

<div class="contenedor">
        <header class="cabecera">
            <h1> Binary Search Tree </h1>
            <p>Estructura de busqueda</p>
        </header>
        <div class="content">
            <a href="#" class="github-link">View the project on GitHub</a>
            <h2>Resumen</h2>
            <p class="description">
	      Si bien la estructura fue pensada para mantener los elementos dentro de manera ordenada, la finalidad de esto fue optimizar la busqueda de elementos de tal manera que podamos hacer consultas de un elemento en particular en menor tiempo.
	    </p>
            <p class="description">
	       La idea de la estrructura es simple. El elemento del hijo izquierdo de un nodo tiene la caracteristica de ser menor o igual al elemento de su padre. El hijo derecho de un nodo tiene la caracteristica de ser mayor o igual a su padre.
	    </p>
	    <p class="description">
	      Es de esta manera que podemos ver que la busqueda dentro de esta estructura nos tomará tiempo logaritmico en un caso promedio que la estructura se encuentre balanceada. Mientras que en el peor caso  la busqueda nos seguira tomando tiempo lineal debido a que se trata de un arbol con una sola rama
	    </p>
	    
            </div>
            <p class="description">
	      Es de esta manera que podemos ver como se comporta la busqueda:  
	    </p>
            <img src="https://compilandoconocimiento.com/wp-content/uploads/2017/01/busqueda.gif?w=275&h=206" class="animated-gif">


	    <h2> Paginas </h2>
	    
	    <div class="link-cards">
	      <a href="https://www.w3schools.com/dsa/dsa_data_binarysearchtrees.php" target="_blank" class="card">
		<div class="preview">
		  <img src="../Img/SiteBST.png" alt="Vista previa de Página 1">
		</div>
		<h3> BST W3Schools </h3>
		<p>En esta página podemos encontrarnos una breve explicación sobre los BST</p>
	      </a>
	      <a href="https://www.geeksforgeeks.org/binary-search-tree-data-structure/" target="_blank" class="card">
		<div class="preview">
		  <img src="../Img/GeeksBST.png" alt="Vista previa de Página 2">
		</div>
		<h3>Geeks for Geeks BST</h3>
		<p>Aquí podemos encontrarnos una explicación de la estructura y algunos ejemplos de su implementación en distintos lenguajes.</p>
	      </a>
	    </div>

	    <div class="video-container">
	      <iframe width="560" height="315" src="https://www.youtube.com/embed/G1VS5FbtMS4?si=rtvqZ6gvJbIZb2Co" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
	    </div>


        </div>	
</div>


<div class="contenedor">
        <header class="cabecera">
            <h1> AVL Tree </h1>
            <p>Estructura de busqueda</p>
        </header>
        <div class="content">
            <a href="#" class="github-link">View the project on GitHub</a>
            <h2>Resumen</h2>
            <p class="description">
	      Los AVL vienen a solucionar uno de los problemas que surgen al usar los BST y es que al no poder balancear los arboles, la busqueda se realiza en tiempo lineal. De esta manera es que solucionamos el problema realizando el balanceo del arbol.
	    </p>
            <p class="description">
	      Continuando la idea del BST original, la estructura se comporta de la misma manera, solo que ahora tenemos que asegurarnos de garantizar que la diferencia en las alturas de cualquier nodo no tiene que ser mayor a 1.
	    </p>
	    <p class="description">
	      Es de esta manera que podemos notar que la busqueda se realiza en tiempo logaritmico, debido a que el arbol garantiza estar balanceado.
	    </p>
	    <p class="description">
	      Es de esta manera que podemos ver como se comporta el balanceo:  
	    </p>
    
        </div>
        <img src="https://upload.wikimedia.org/wikipedia/commons/9/9c/Rebalance_animation_simple.gif" class="animated-gif">


	    <h2> Paginas </h2>
	    
	    <div class="link-cards">
	      <a href="https://www.w3schools.com/dsa/dsa_data_avltrees.php" target="_blank" class="card">
		<div class="preview">
		  <img src="../Img/SiteAVL.png" alt="Vista previa de Página 1">
		</div>
		<h3> AVL W3Schools </h3>
		<p>En esta página podemos encontrarnos una breve explicación sobre los BST</p>
	      </a>
	      <a href="https://www.geeksforgeeks.org/introduction-to-avl-tree/" target="_blank" class="card">
		<div class="preview">
		  <img src="../Img/GeeksAVL.png" alt="Vista previa de Página 2">
		</div>
		<h3>Geeks for Geeks AVL</h3>
		<p>Aquí podemos encontrarnos una explicación de la estructura y algunos ejemplos de su implementación en distintos lenguajes.</p>
	      </a>
	    </div>

	    <div class="video-container">
	      <iframe width="560" height="315" src="https://www.youtube.com/embed/vRwi_UcZGjU?si=IopQtKZZpgZz5YS9" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
	    </div>


        </div>	
</div>

<div class="contenedor">
        <header class="cabecera">
            <h1> Binary Search </h1>
            <p>Algoritmo de busqueda</p>
        </header>
        <div class="content">
            <a href="#" class="github-link">View the project on GitHub</a>
            <h2>Resumen</h2>
            <p class="description">
	      El algoritmo Binary Search es el algoritmo sobre el cual se basan las busquedas de los arboles, este algoritmo depende de que los elementos se encuentren ordenados en primera instancia. 
	    </p>
            <p class="description">
	      El algoritmo consiste en tomar el elemento a la mitad y compararlo con el elemento que buscamos, si es mayor entonces revisamos recursivamente en la mitad derecha, si es menos entonces revisaremos recursivamente en la mitad izquierda. 
	    </p>
	    <p class="description">
	      Es de esta manera que podemos notar que la busqueda se realiza en tiempo logaritmico.
	    </p>
	    <p class="description">
	      Es de esta manera que podemos ver como se comporta la busqueda:  
	    </p>
    
        </div>
        <img src="https://www.mathwarehouse.com/programming/images/binary-vs-linear-search/binary-and-linear-search-animations.gif" class="animated-gif">


	    <h2> Paginas </h2>
	    
	    <div class="link-cards">
	      <a href="https://www.w3schools.com/dsa/dsa_algo_binarysearch.php" target="_blank" class="card">
		<div class="preview">
		  <img src="../Img/SiteBS.png" alt="Vista previa de Página 1">
		</div>
		<h3> Binary Search W3Schools </h3>
		<p>En esta página podemos encontrarnos una breve explicación sobre Binary Search</p>
	      </a>
	      <a href="https://www.geeksforgeeks.org/binary-search/" target="_blank" class="card">
		<div class="preview">
		  <img src="../Img/GeeksBS.png" alt="Vista previa de Página 2">
		</div>
		<h3>Geeks for Geeks Binary Search</h3>
		<p>Aquí podemos encontrarnos una explicación del algoritmo y algunos ejemplos de su implementación en distintos lenguajes.</p>
	      </a>
	    </div>

	    <div class="video-container">
	      <iframe width="560" height="315" src="https://www.youtube.com/embed/MFhxShGxHWc?si=bcsxDQQmJTPZMMhm" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
	    </div>


        </div>	
</div>

<div class="contenedor">
        <header class="cabecera">
            <h1> Quick Select </h1>
            <p>Algoritmo de busqueda</p>
        </header>
        <div class="content">
            <a href="#" class="github-link">View the project on GitHub</a>
            <h2>Resumen</h2>
            <p class="description">
	      El algoritmo de un QuickSelect es un algoritmo para la busqueda del k-esimo elemento, este algoritmo es parecido a binarySearch. Parecido al ordenamiento de QuickSort, QuickSelect se trata de buscar un pivote y empezar a ordenar de acuerdo a ese pivote.
	    </p>
            <p class="description">
	      A diferencia de QuickSort, QuickSelect tendrá recursión solo en una mitad generada por el pivote, debido a que estamos buscando y no ordenando.
	    </p>
	    <p class="description">
	      Es de esta manera que podemos notar que la busqueda se realiza en tiempo lineal.
	    </p>
	    <p class="description">
	      Es de esta manera que podemos ver como se comporta la busqueda:  
	    </p>
    
        </div>
        <img src="https://upload.wikimedia.org/wikipedia/commons/0/04/Selecting_quickselect_frames.gif" class="animated-gif">


	    <h2> Paginas </h2>
	    
	    <div class="link-cards">
	      <a href="https://medium.com/nerd-for-tech/quick-select-algorithm-17ac146b6218" target="_blank" class="card">
		<div class="preview">
		  <img src="../Img/SiteQS.png" alt="Vista previa de Página 1">
		</div>
		<h3> QuickSelect Medium </h3>
		<p>En esta página podemos encontrarnos una breve explicación sobre QuickSelect</p>
	      </a>
	      <a href="https://www.geeksforgeeks.org/quickselect-algorithm/" target="_blank" class="card">
		<div class="preview">
		  <img src="../Img/GeeksQS.png" alt="Vista previa de Página 2">
		</div>
		<h3>Geeks for Geeks QS</h3>
		<p>Aquí podemos encontrarnos una explicación del algoritmo y algunos ejemplos de su implementación en distintos lenguajes.</p>
	      </a>
	    </div>

	    <div class="video-container">
	      <iframe width="560" height="315" src="https://www.youtube.com/embed/AqMiMkPOutQ?si=QHM6j0QquJ0BAxgF" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
	    </div>


        </div>	
</div>


</body>
</html>
